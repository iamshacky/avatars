<!doctype html>
<meta charset="utf-8" />
<title>Avatar Viewer</title>
<style>
  #face { width: 240px; height: 240px; border-radius: 50%; background: #eee;
          display: flex; align-items: center; justify-content: center; margin: 24px auto; }
  #mouth { width: 64px; height: 12px; border-radius: 8px; background: #333;
          transition: height 60ms; }
  body { font-family: sans-serif; max-width: 720px; margin: 20px auto; }
  label,input,button { font-size: 16px; }
</style>
<body>
  <h1>Avatar Viewer</h1>

  <div>
    <label>Room: <input id="room" value="default"></label>
    <label>User: <input id="user" value="viewer"></label>
    <button id="joinBtn">Join</button>
  </div>

  <div id="face"><div id="mouth"></div></div>
  <audio id="audio" autoplay></audio>

  <div>
    <textarea id="msg" rows="3" style="width:100%;">Say hello to everyone.</textarea>
    <div style="margin-top:8px;">
      <button id="speakOnce">Speak (transient)</button>
      <button id="stayJoin">Join (persistent)</button>
      <button id="staySpeak">Speak (persistent)</button>
      <button id="stayLeave">Leave</button>
      <button id="testTone">Test tone (20s)</button>
    </div>
  </div>

  <script type="module">
    // LiveKit client (pin to a known good version)
    import { Room, RoomEvent } from "https://cdn.jsdelivr.net/npm/livekit-client@2.15.7/dist/livekit-client.esm.mjs";

    // --- Single-file, dual-environment config ---
    const params = new URLSearchParams(location.search);
    const API_OVERRIDE = params.get('api');
    const DEFAULT_RAILWAY = "https://exciting-nourishment-production.up.railway.app";

    // If ?api provided -> use it
    // else if we're hosted on Railway -> same-origin
    // else (likely localhost Apache) -> default to Railway backend
    const onRailway = location.hostname.endsWith("railway.app");
    const BOT_BASE = API_OVERRIDE || (onRailway ? location.origin : DEFAULT_RAILWAY);

    // If you enabled the x-bot-auth guard on the server, put the secret here:
    const BOT_AUTH = "";

    // --- Elements ---
    const audioEl = document.getElementById("audio");
    const mouthEl = document.getElementById("mouth");
    const roomInput = document.getElementById("room");
    const userInput = document.getElementById("user");
    let room;

    // --- Resilient autoplay / unmute ---
    const clickToUnmute = () => {
      try {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) new AC().resume().catch(()=>{});
      } catch {}
      audioEl.muted = false;
      audioEl.play().catch(e => console.warn("[audio] play blocked:", e?.message || e));
    };
    window.addEventListener('click', clickToUnmute, { once: true });
    audioEl.addEventListener('play', () => console.log('[audio] playing'));
    audioEl.addEventListener('error', (e) => console.warn('[audio] error', e));

    // --- Helpers ---
    async function getClientToken(roomName, userName) {
      const r = await fetch(`${BOT_BASE}/token?room=${encodeURIComponent(roomName)}&user=${encodeURIComponent(userName)}`);
      if (!r.ok) throw new Error("token fetch failed");
      return r.text();
    }

    function animateMouth(stream) {
      const AC = window.AudioContext || window.webkitAudioContext;
      const ctx = new AC();
      const src = ctx.createMediaStreamSource(stream);
      const analyser = ctx.createAnalyser();
      analyser.fftSize = 512;
      src.connect(analyser);
      const data = new Uint8Array(analyser.frequencyBinCount);
      (function tick(){
        analyser.getByteFrequencyData(data);
        let level = 0;
        for (let i = 0; i < data.length; i++) level += data[i];
        level = level / data.length;
        const h = 10 + Math.min(90, level / 2.5);
        mouthEl.style.height = h + "px";
        requestAnimationFrame(tick);
      })();
    }

    async function connect() {
      const roomName = roomInput.value || "default";
      const userName = userInput.value || ("viewer-" + Math.random().toString(36).slice(2,8));
      const token = await getClientToken(roomName, userName);

      room = new Room();
      room.on(RoomEvent.ConnectionStateChanged, (s) => console.log("[LK] ConnectionState:", s));
      room.on(RoomEvent.ParticipantConnected, (p) => console.log("[LK] Participant+", p.identity));
      room.on(RoomEvent.ParticipantDisconnected, (p) => console.log("[LK] Participant-", p.identity));

      room.on(RoomEvent.TrackSubscribed, (_track, pub, participant) => {
        if (pub.kind === "audio") {
          console.log("[LK] TrackSubscribed (audio) from", participant.identity, pub.trackSid || pub.sid || pub.trackName);
          const mediaStream = new MediaStream([pub.track.mediaStreamTrack]);
          audioEl.srcObject = mediaStream;
          audioEl.muted = false;
          audioEl.play().then(() => {
            console.log("[audio] play() resolved after subscribe");
          }).catch((e) => {
            console.warn("[audio] play blocked:", e?.message || e);
          });
          animateMouth(mediaStream);
        }
      });

      await room.connect("wss://project1-5bgowgi3.livekit.cloud", token);
      console.log("Viewer connected. my identity:", room.localParticipant?.identity);

      // v2: remoteParticipants is a Map; fallback if needed
      try {
        const map = room.remoteParticipants || room.participants;
        map && map.forEach?.((p) => console.log("[LK] Existing participant:", p.identity));
      } catch {}
    }

    document.getElementById("joinBtn").onclick = connect;

    async function postJSON(path, body) {
      const headers = { "content-type": "application/json" };
      if (BOT_AUTH) headers["x-bot-auth"] = BOT_AUTH;
      const r = await fetch(BOT_BASE + path, { method: "POST", headers, body: JSON.stringify(body) });
      let t = ""; try { t = await r.text(); } catch {}
      let j; try { j = t ? JSON.parse(t) : null; } catch {}
      if (!r.ok) throw new Error(`${path} ${r.status}: ${t || "request failed"}`);
      return j ?? {};
    }

    // Buttons â†’ API
    document.getElementById("testTone").onclick = async () => {
      try {
        const roomName = roomInput.value || "default";
        const res = await postJSON("/diag/tone_hold", { roomName, holdMs: 20000, freq: 440 });
        console.log("testTone ok", res);
      } catch (e) { console.error(e); alert(e.message); }
    };

    document.getElementById('speakOnce').onclick = async () => {
      const text = (document.getElementById('prompt')?.value || "Say hi!");
      const roomName = "default";

      const r = await fetch("/message", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text, roomName })
      });
      const data = await r.json();
      console.log("speakOnce ok", data);

      // Play the natural TTS straight in the browser
      if (data?.audioUrl) {
        const audio = new Audio(data.audioUrl);
        try {
          await audio.play();
          console.log("[audio] playing from", data.audioUrl);
        } catch (err) {
          console.warn("Audio play failed (user gesture / permissions?)", err);
        }
      }
    };

    document.getElementById("stayJoin").onclick = async () => {
      try {
        const roomName = roomInput.value || "default";
        const res = await postJSON("/join", { roomName });
        console.log("stayJoin ok", res);
      } catch (e) { console.error(e); alert(e.message); }
    };

    document.getElementById("staySpeak").onclick = async () => {
      try {
        const roomName = roomInput.value || "default";
        const text = document.getElementById("msg").value || "Introduce yourself.";
        const res = await postJSON("/message", { roomName, text, keep: true });
        console.log("staySpeak ok", res);
      } catch (e) { console.error(e); alert(e.message); }
    };

    document.getElementById("stayLeave").onclick = async () => {
      try {
        const res = await postJSON("/leave", {});
        console.log("stayLeave ok", res);
      } catch (e) { console.error(e); alert(e.message); }
    };
  </script>
</body>
